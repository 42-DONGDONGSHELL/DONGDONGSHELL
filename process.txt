< {file}
<< {file}
> {file}
>> {file}
{command} | {command}

isquote
isredir = in, out
redircount
< file echo zzz"a b c d | " | cat 

`zzza b c d | `

1. tokenizing
['<' = redirection, '>' = redirection, 'file' = literal, 'echo' = literal, '"a b c d | "' = literal, '|' = pipe, 'cat' = literal]

2. make command
t_command
- command = [('echo' = literal), ('"a b c d | "' = literal)]
- infile redirection = [('<' = redirection, 'file' = literal), ]
- outfile redirection = NULL
- t_command* next command

t_command
- command = [('cat' = literal)]
- infile redirection = NULL
- outfile redirection = NULL
- t_command* next command = NULL

3. really make command

- command t_arguments -> char**

readline -> parameter expansion -> fork -> redirection -> execve


bnf EBNF 




<input> ::=  '<input | <cmd>' | <cmd>
<cmd>:== <literal> | <iotoken><literal> | <litaral><iotoken> | <iotoken><literal><iotoken>
Iotoken ::= <rediection> <literal>
Iotoken ::= <rediection> <literal>
Iotoken ::= <rediection> <literal>
Iotoken ::= <rediection> <literal>

rediection ::= '<' | '<<'| '>' | '>>'
litaral ::= [0-9A-Za-z./,+-_]
literal ::= '<litaral>'



[Syntax Error]
- <redirection> <redirection> //규칙위배 ->Syntax Error
- <rediection> <PIPE> // nearby '|' 


t_parser{
    t_flag doublequote;
    t_flag quote;
}

if(parser.doublequote)
    parse.doublequote = false;
if(parser.doublequote)
    

t_parse_tree{
    enum E_TOKEN_TYPE = cmmd | INFILE | HEREDOC | APPEND | OUTFILE | ARGUMENT



    char *
}


" cmd << heredoc  " | "cmd << heredoc >> append < infile > outfile argument << heredoc"



{
    cmd: char *
    argument char **
    files: 
    envp: char ***
}

file_list{
    char *fiename;
    char *limeter; = (heredoc = NOT NULL else NULL)
    enum type INFILE | OUTIFLE | HEREDOC | APPEND 
    
}






